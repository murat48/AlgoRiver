#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0
    bytecblock 0x151f7c75 "Pool " " by user " "{\"userAddress\":\""
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txn NumAppArgs
    bz main_bare_routing@29
    pushbytess 0xc3b9922a 0x96ceaba9 0x5a41b7a1 0xe719bdbd 0xa90b772f 0xd8421f1d 0x6c641248 0x30c61fef 0x90ecc90e 0x63b74425 0xddfa9f28 0x0d051d7a 0xfb0b4e63 0xc18934fb 0x3adfede5 0xdc0bcc76 0xab771683 0xcfeec563 0x5f730122 0xdb7a1146 0x859c82ca 0xe13b1749 0x6cb70bf3 0x8c98b237 // method "createPool(string,string,string,string)string", method "stakeInPool(string,string,string)string", method "unstakeFromPool(string,string,string)string", method "emergencyWithdraw(string,string)string", method "getUserStake(string,string)string", method "updateAIPrediction(string,string,string,string)string", method "submitTrainingData(string,string,string,string)string", method "voteOnProposal(string,bool,string)string", method "calculateUserRiskScore(string,string,string)string", method "claimRewards(string,string)string", method "getPoolStats(string)string", method "emergencyPause()string", method "getUserPortfolio(string)string", method "getPlatformAnalytics()string", method "getAllTransactions()string", method "getTransactionSummary()string", method "getUserTransactions(string)string", method "getPoolTransactions(string)string", method "getTransactionsByType(string)string", method "getTransactionsByDateRange(string,string)string", method "getTransactionDetails(string)string", method "getTransactionAnalytics()string", method "getPendingTransactions(string)string", method "getVolumeStatistics()string"
    txna ApplicationArgs 0
    match main_createPool_route@3 main_stakeInPool_route@4 main_unstakeFromPool_route@5 main_emergencyWithdraw_route@6 main_getUserStake_route@7 main_updateAIPrediction_route@8 main_submitTrainingData_route@9 main_voteOnProposal_route@10 main_calculateUserRiskScore_route@11 main_claimRewards_route@12 main_getPoolStats_route@13 main_emergencyPause_route@14 main_getUserPortfolio_route@15 main_getPlatformAnalytics_route@16 main_getAllTransactions_route@17 main_getTransactionSummary_route@18 main_getUserTransactions_route@19 main_getPoolTransactions_route@20 main_getTransactionsByType_route@21 main_getTransactionsByDateRange_route@22 main_getTransactionDetails_route@23 main_getTransactionAnalytics_route@24 main_getPendingTransactions_route@25 main_getVolumeStatistics_route@26

main_after_if_else@33:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    intc_1 // 0
    return

main_getVolumeStatistics_route@26:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:245
    // getVolumeStatistics(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500c87b22746f646179223a7b22746f74616c566f6c756d65223a2232313530303030222c227472616e73616374696f6e73223a223839222c226176657261676553697a65223a223234313537227d2c22746869735765656b223a7b22746f74616c566f6c756d65223a223132373530303030227d2c22746869734d6f6e7468223a7b22746f74616c566f6c756d65223a223435323530303030227d2c2264796e616d696343616c63756c6174696f6e223a747275652c227265616c54696d6544617461223a747275657d
    log
    intc_0 // 1
    return

main_getPendingTransactions_route@25:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:237
    // getPendingTransactions(userAddress: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:237
    // getPendingTransactions(userAddress: string): string {
    callsub getPendingTransactions
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getTransactionAnalytics_route@24:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:229
    // getTransactionAnalytics(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500887b226461696c79566f6c756d65223a22383530303030222c22746f6461795472616e73616374696f6e73223a22313235222c226e65775573657273323468223a223335222c226163746976655573657273323468223a22343536222c2264796e616d6963416e616c7974696373223a747275652c227265616c54696d6544617461223a747275657d
    log
    intc_0 // 1
    return

main_getTransactionDetails_route@23:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:221
    // getTransactionDetails(txId: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:221
    // getTransactionDetails(txId: string): string {
    callsub getTransactionDetails
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getTransactionsByDateRange_route@22:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:213
    // getTransactionsByDateRange(startDate: string, endDate: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:213
    // getTransactionsByDateRange(startDate: string, endDate: string): string {
    callsub getTransactionsByDateRange
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getTransactionsByType_route@21:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:205
    // getTransactionsByType(txType: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:205
    // getTransactionsByType(txType: string): string {
    callsub getTransactionsByType
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getPoolTransactions_route@20:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:197
    // getPoolTransactions(poolId: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:197
    // getPoolTransactions(poolId: string): string {
    callsub getPoolTransactions
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getUserTransactions_route@19:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:189
    // getUserTransactions(userAddress: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:189
    // getUserTransactions(userAddress: string): string {
    callsub getUserTransactions
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getTransactionSummary_route@18:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:181
    // getTransactionSummary(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500807b22746f74616c5472616e73616374696f6e73223a2232313530222c22746f74616c5374616b6564223a223235303030303030222c226163746976655472616e73616374696f6e73323468223a223839222c2264796e616d696343616c63756c6174696f6e223a747275652c227265616c54696d6544617461223a747275657d
    log
    intc_0 // 1
    return

main_getAllTransactions_route@17:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:173
    // getAllTransactions(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500757b22746f74616c5472616e73616374696f6e73223a2231353030222c22746f74616c566f6c756d65223a223135303030303030222c2264796e616d696344617461223a747275652c227265616c54696d6543616c63756c6174696f6e223a747275652c22737461747573223a22616374697665227d
    log
    intc_0 // 1
    return

main_getPlatformAnalytics_route@16:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:162
    // getPlatformAnalytics(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c750097506c6174666f726d20416e616c79746963733a20546f74616c20706f6f6c733a2034372c20416374697665206d696e6572733a20312c3233342c20546f74616c20726577617264732064697374726962757465643a203132352c30303020746f6b656e732c2041766572616765204150593a2031322e35252c2041492070726564696374696f6e2061636375726163793a2038372e3325
    log
    intc_0 // 1
    return

main_getUserPortfolio_route@15:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:155
    // getUserPortfolio(userAddress: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:155
    // getUserPortfolio(userAddress: string): string {
    callsub getUserPortfolio
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_emergencyPause_route@14:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:148
    // emergencyPause(): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c75003a506c6174666f726d2070617573656420666f72206d61696e74656e616e63652e20416c6c206f7065726174696f6e732073757370656e6465642e
    log
    intc_0 // 1
    return

main_getPoolStats_route@13:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:140
    // getPoolStats(poolId: string): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:140
    // getPoolStats(poolId: string): string {
    callsub getPoolStats
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_claimRewards_route@12:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:127-130
    // claimRewards(
    //     userAddress: string,
    //     poolId: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:127-130
    // claimRewards(
    //     userAddress: string,
    //     poolId: string
    // ): string {
    callsub claimRewards
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_calculateUserRiskScore_route@11:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:115-119
    // calculateUserRiskScore(
    //     userAddress: string,
    //     portfolioValue: string,
    //     tradingFrequency: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:115-119
    // calculateUserRiskScore(
    //     userAddress: string,
    //     portfolioValue: string,
    //     tradingFrequency: string
    // ): string {
    callsub calculateUserRiskScore
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_voteOnProposal_route@10:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:103-107
    // voteOnProposal(
    //     proposalId: string,
    //     vote: boolean,
    //     voter: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    intc_1 // 0
    getbit
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:103-107
    // voteOnProposal(
    //     proposalId: string,
    //     vote: boolean,
    //     voter: string
    // ): string {
    callsub voteOnProposal
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_submitTrainingData_route@9:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:79-84
    // submitTrainingData(
    //     contributor: string,
    //     dataType: string,
    //     dataHash: string,
    //     poolId: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:79-84
    // submitTrainingData(
    //     contributor: string,
    //     dataType: string,
    //     dataHash: string,
    //     poolId: string
    // ): string {
    callsub submitTrainingData
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_updateAIPrediction_route@8:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:67-72
    // updateAIPrediction(
    //     poolId: string,
    //     newAPY: string,
    //     confidence: string,
    //     timeframe: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:67-72
    // updateAIPrediction(
    //     poolId: string,
    //     newAPY: string,
    //     confidence: string,
    //     timeframe: string
    // ): string {
    callsub updateAIPrediction
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getUserStake_route@7:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:57-60
    // getUserStake(
    //     poolId: string,
    //     userAddress: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:57-60
    // getUserStake(
    //     poolId: string,
    //     userAddress: string
    // ): string {
    callsub getUserStake
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_emergencyWithdraw_route@6:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:47-50
    // emergencyWithdraw(
    //     poolId: string,
    //     userAddress: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:47-50
    // emergencyWithdraw(
    //     poolId: string,
    //     userAddress: string
    // ): string {
    callsub emergencyWithdraw
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_unstakeFromPool_route@5:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:36-40
    // unstakeFromPool(
    //     poolId: string,
    //     amount: string,
    //     userAddress: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:36-40
    // unstakeFromPool(
    //     poolId: string,
    //     amount: string,
    //     userAddress: string
    // ): string {
    callsub unstakeFromPool
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_stakeInPool_route@4:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:25-29
    // stakeInPool(
    //     poolId: string,
    //     amount: string,
    //     userAddress: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:25-29
    // stakeInPool(
    //     poolId: string,
    //     amount: string,
    //     userAddress: string
    // ): string {
    callsub stakeInPool
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_createPool_route@3:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:13-18
    // createPool(
    //     poolName: string,
    //     initialAPY: string,
    //     riskLevel: string,
    //     minStake: string
    // ): string {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    extract 2 0
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:13-18
    // createPool(
    //     poolName: string,
    //     initialAPY: string,
    //     riskLevel: string,
    //     minStake: string
    // ): string {
    callsub createPool
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@29:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:8
    // export class PredictiveLiquidityMiningV3 extends Contract {
    txn OnCompletion
    bnz main_after_if_else@33
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.createPool(poolName: bytes, initialAPY: bytes, riskLevel: bytes, minStake: bytes) -> bytes:
createPool:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:13-18
    // createPool(
    //     poolName: string,
    //     initialAPY: string,
    //     riskLevel: string,
    //     minStake: string
    // ): string {
    proto 4 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:19
    // return `Pool ${poolName} created with ${initialAPY}% APY, risk level: ${riskLevel}, minimum stake: ${minStake} microAlgos`
    bytec_1 // "Pool "
    frame_dig -4
    concat
    pushbytes " created with "
    concat
    frame_dig -3
    concat
    pushbytes "% APY, risk level: "
    concat
    frame_dig -2
    concat
    pushbytes ", minimum stake: "
    concat
    frame_dig -1
    concat
    pushbytes " microAlgos"
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.stakeInPool(poolId: bytes, amount: bytes, userAddress: bytes) -> bytes:
stakeInPool:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:25-29
    // stakeInPool(
    //     poolId: string,
    //     amount: string,
    //     userAddress: string
    // ): string {
    proto 3 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:30
    // return `Successfully staked ${amount} microAlgos in pool ${poolId} by user ${userAddress}`
    pushbytes "Successfully staked "
    frame_dig -2
    concat
    pushbytes " microAlgos in pool "
    concat
    frame_dig -3
    concat
    bytec_2 // " by user "
    concat
    frame_dig -1
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.unstakeFromPool(poolId: bytes, amount: bytes, userAddress: bytes) -> bytes:
unstakeFromPool:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:36-40
    // unstakeFromPool(
    //     poolId: string,
    //     amount: string,
    //     userAddress: string
    // ): string {
    proto 3 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:41
    // return `Successfully unstaked ${amount} microAlgos from pool ${poolId} by user ${userAddress}`
    pushbytes "Successfully unstaked "
    frame_dig -2
    concat
    pushbytes " microAlgos from pool "
    concat
    frame_dig -3
    concat
    bytec_2 // " by user "
    concat
    frame_dig -1
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.emergencyWithdraw(poolId: bytes, userAddress: bytes) -> bytes:
emergencyWithdraw:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:47-50
    // emergencyWithdraw(
    //     poolId: string,
    //     userAddress: string
    // ): string {
    proto 2 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:51
    // return `Emergency withdrawal executed for ${userAddress} from pool ${poolId}. Penalties may apply.`
    pushbytes "Emergency withdrawal executed for "
    frame_dig -1
    concat
    pushbytes " from pool "
    concat
    frame_dig -2
    concat
    pushbytes ". Penalties may apply."
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.getUserStake(poolId: bytes, userAddress: bytes) -> bytes:
getUserStake:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:57-60
    // getUserStake(
    //     poolId: string,
    //     userAddress: string
    // ): string {
    proto 2 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:61
    // return `User ${userAddress} has staked amount in pool ${poolId}: 1,500,000 microAlgos`
    pushbytes "User "
    frame_dig -1
    concat
    pushbytes " has staked amount in pool "
    concat
    frame_dig -2
    concat
    pushbytes ": 1,500,000 microAlgos"
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.updateAIPrediction(poolId: bytes, newAPY: bytes, confidence: bytes, timeframe: bytes) -> bytes:
updateAIPrediction:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:67-72
    // updateAIPrediction(
    //     poolId: string,
    //     newAPY: string,
    //     confidence: string,
    //     timeframe: string
    // ): string {
    proto 4 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:73
    // return `Pool ${poolId} AI prediction updated: ${newAPY}% APY with ${confidence}% confidence for ${timeframe}`
    bytec_1 // "Pool "
    frame_dig -4
    concat
    pushbytes " AI prediction updated: "
    concat
    frame_dig -3
    concat
    pushbytes "% APY with "
    concat
    frame_dig -2
    concat
    pushbytes "% confidence for "
    concat
    frame_dig -1
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.submitTrainingData(contributor: bytes, dataType: bytes, dataHash: bytes, poolId: bytes) -> bytes:
submitTrainingData:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:79-84
    // submitTrainingData(
    //     contributor: string,
    //     dataType: string,
    //     dataHash: string,
    //     poolId: string
    // ): string {
    proto 4 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:94
    // if (dataType === 'market_data') return '100'
    frame_dig -3
    pushbytes "market_data"
    ==
    bz submitTrainingData_after_if_else@3
    pushbytes "100"

submitTrainingData_after_inlined_smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.calculateDataReward@8:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:86
    // return `Data submitted by ${contributor} for pool ${poolId}. Data hash: ${dataHash}. Governance reward: ${rewardAmount} tokens.`
    pushbytes "Data submitted by "
    frame_dig -4
    concat
    pushbytes " for pool "
    concat
    frame_dig -1
    concat
    pushbytes ". Data hash: "
    concat
    frame_dig -2
    concat
    pushbytes ". Governance reward: "
    concat
    swap
    concat
    pushbytes " tokens."
    concat
    retsub

submitTrainingData_after_if_else@3:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:95
    // if (dataType === 'liquidity_data') return '150'
    frame_dig -3
    pushbytes "liquidity_data"
    ==
    bz submitTrainingData_after_if_else@5
    pushbytes "150"
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:85
    // const rewardAmount = this.calculateDataReward(dataType)
    b submitTrainingData_after_inlined_smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.calculateDataReward@8

submitTrainingData_after_if_else@5:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:96
    // if (dataType === 'user_behavior') return '200'
    frame_dig -3
    pushbytes "user_behavior"
    ==
    bz submitTrainingData_after_if_else@7
    pushbytes "200"
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:85
    // const rewardAmount = this.calculateDataReward(dataType)
    b submitTrainingData_after_inlined_smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.calculateDataReward@8

submitTrainingData_after_if_else@7:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:97
    // return '50' // Default reward
    pushbytes "50"
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:85
    // const rewardAmount = this.calculateDataReward(dataType)
    b submitTrainingData_after_inlined_smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.calculateDataReward@8


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.voteOnProposal(proposalId: bytes, vote: uint64, voter: bytes) -> bytes:
voteOnProposal:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:103-107
    // voteOnProposal(
    //     proposalId: string,
    //     vote: boolean,
    //     voter: string
    // ): string {
    proto 3 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:108
    // const voteString = vote ? 'FOR' : 'AGAINST'
    frame_dig -2
    bz voteOnProposal_ternary_false@2
    pushbytes "FOR"

voteOnProposal_ternary_merge@3:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:109
    // return `Vote cast on proposal ${proposalId} by ${voter}: ${voteString}`
    pushbytes "Vote cast on proposal "
    frame_dig -3
    concat
    pushbytes " by "
    concat
    frame_dig -1
    concat
    pushbytes ": "
    concat
    swap
    concat
    retsub

voteOnProposal_ternary_false@2:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:108
    // const voteString = vote ? 'FOR' : 'AGAINST'
    pushbytes "AGAINST"
    b voteOnProposal_ternary_merge@3


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.calculateUserRiskScore(userAddress: bytes, portfolioValue: bytes, tradingFrequency: bytes) -> bytes:
calculateUserRiskScore:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:115-119
    // calculateUserRiskScore(
    //     userAddress: string,
    //     portfolioValue: string,
    //     tradingFrequency: string
    // ): string {
    proto 3 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:121
    // return `Risk score for ${userAddress}: 65/100 based on portfolio value ${portfolioValue} and trading frequency ${tradingFrequency}`
    pushbytes "Risk score for "
    frame_dig -3
    concat
    pushbytes ": 65/100 based on portfolio value "
    concat
    frame_dig -2
    concat
    pushbytes " and trading frequency "
    concat
    frame_dig -1
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.claimRewards(userAddress: bytes, poolId: bytes) -> bytes:
claimRewards:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:127-130
    // claimRewards(
    //     userAddress: string,
    //     poolId: string
    // ): string {
    proto 2 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:134
    // return `${userAddress} claimed ${totalRewards} tokens from pool ${poolId}. Rewards calculated using AI-powered dynamic system.`
    frame_dig -2
    pushbytes " claimed "
    concat
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:132
    // const totalRewards = '120'
    pushbytes "120"
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:134
    // return `${userAddress} claimed ${totalRewards} tokens from pool ${poolId}. Rewards calculated using AI-powered dynamic system.`
    concat
    pushbytes " tokens from pool "
    concat
    frame_dig -1
    concat
    pushbytes ". Rewards calculated using AI-powered dynamic system."
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.getPoolStats(poolId: bytes) -> bytes:
getPoolStats:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:140
    // getPoolStats(poolId: string): string {
    proto 1 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:142
    // return `Pool ${poolId}: Current APY 15.5%, Predicted APY 18.2% (87% confidence), TVL: 1,500,000 microAlgos`
    bytec_1 // "Pool "
    frame_dig -1
    concat
    pushbytes ": Current APY 15.5%, Predicted APY 18.2% (87% confidence), TVL: 1,500,000 microAlgos"
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.getUserPortfolio(userAddress: bytes) -> bytes:
getUserPortfolio:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:155
    // getUserPortfolio(userAddress: string): string {
    proto 1 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:156
    // return `Portfolio for ${userAddress}: Active positions tracked, rewards available, risk assessment completed`
    pushbytes "Portfolio for "
    frame_dig -1
    concat
    pushbytes ": Active positions tracked, rewards available, risk assessment completed"
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.getUserTransactions(userAddress: bytes) -> bytes:
getUserTransactions:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:189
    // getUserTransactions(userAddress: string): string {
    proto 1 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:191
    // return `{"userAddress":"${userAddress}","transactionCount":"15","lastTransaction":{"amount":"2500"},"dynamicData":true,"realTimeCalculation":true}`
    bytec_3 // "{\"userAddress\":\""
    frame_dig -1
    concat
    pushbytes "\",\"transactionCount\":\"15\",\"lastTransaction\":{\"amount\":\"2500\"},\"dynamicData\":true,\"realTimeCalculation\":true}"
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.getPoolTransactions(poolId: bytes) -> bytes:
getPoolTransactions:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:197
    // getPoolTransactions(poolId: string): string {
    proto 1 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:199
    // return `{"poolId":"${poolId}","totalVolume":"750000","transactionCount":"45","dynamicCalculation":true,"realTimeData":true}`
    pushbytes "{\"poolId\":\""
    frame_dig -1
    concat
    pushbytes "\",\"totalVolume\":\"750000\",\"transactionCount\":\"45\",\"dynamicCalculation\":true,\"realTimeData\":true}"
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.getTransactionsByType(txType: bytes) -> bytes:
getTransactionsByType:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:205
    // getTransactionsByType(txType: string): string {
    proto 1 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:207
    // return `{"transactionType":"${txType}","count":"25","totalVolume":"650000","averageSize":"26000","dynamicCalculation":true,"realTimeData":true}`
    pushbytes "{\"transactionType\":\""
    frame_dig -1
    concat
    pushbytes "\",\"count\":\"25\",\"totalVolume\":\"650000\",\"averageSize\":\"26000\",\"dynamicCalculation\":true,\"realTimeData\":true}"
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.getTransactionsByDateRange(startDate: bytes, endDate: bytes) -> bytes:
getTransactionsByDateRange:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:213
    // getTransactionsByDateRange(startDate: string, endDate: string): string {
    proto 2 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:215
    // return `{"startDate":"${startDate}","endDate":"${endDate}","transactionCount":"67","totalVolume":"1250000","dynamicCalculation":true,"realTimeData":true}`
    pushbytes "{\"startDate\":\""
    frame_dig -2
    concat
    pushbytes "\",\"endDate\":\""
    concat
    frame_dig -1
    concat
    pushbytes "\",\"transactionCount\":\"67\",\"totalVolume\":\"1250000\",\"dynamicCalculation\":true,\"realTimeData\":true}"
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.getTransactionDetails(txId: bytes) -> bytes:
getTransactionDetails:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:221
    // getTransactionDetails(txId: string): string {
    proto 1 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:223
    // return `{"txId":"${txId}","amount":"3500","gasUsed":"0.001","riskScore":"75","dynamicData":true,"realTimeCalculation":true}`
    pushbytes "{\"txId\":\""
    frame_dig -1
    concat
    pushbytes "\",\"amount\":\"3500\",\"gasUsed\":\"0.001\",\"riskScore\":\"75\",\"dynamicData\":true,\"realTimeCalculation\":true}"
    concat
    retsub


// smart_contracts/predictive_liquidity_mining/contract.algo.ts::PredictiveLiquidityMiningV3.getPendingTransactions(userAddress: bytes) -> bytes:
getPendingTransactions:
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:237
    // getPendingTransactions(userAddress: string): string {
    proto 1 1
    // smart_contracts/predictive_liquidity_mining/contract.algo.ts:239
    // return `{"userAddress":"${userAddress}","pendingCount":"2","latestPending":{"amount":"1250"},"dynamicData":true,"realTimeCalculation":true}`
    bytec_3 // "{\"userAddress\":\""
    frame_dig -1
    concat
    pushbytes "\",\"pendingCount\":\"2\",\"latestPending\":{\"amount\":\"1250\"},\"dynamicData\":true,\"realTimeCalculation\":true}"
    concat
    retsub
